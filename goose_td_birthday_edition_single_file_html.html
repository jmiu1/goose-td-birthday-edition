<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Goose TD ‚Äî Birthday Edition</title>
  <style>
    :root {
      --bg:#0e1a11;       /* page bg */
      --grass:#2f8f46;    /* map grass */
      --river:#4ca3e2;    /* water */
      --bridge:#8b5a2b;   /* bridge */
      --path:#b38b5e;     /* dirt path */
      --ink:#0a0a0a;      /* text */
      --panel:#ffffff;    /* panel bg */
      --panel-ink:#0f172a;/* panel text */
      --accent:#10b981;   /* buttons */
      --accent-2:#6366f1;
      --danger:#ef4444;
      --gold:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,sans-serif;color:var(--panel)}
    .wrap{display:grid;grid-template-columns: 1fr 320px;gap:14px;max-width:1280px;margin:14px auto;padding:14px}
    canvas{background:#1d3d25;border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.35)}
    aside{background:var(--panel);color:var(--panel-ink);border-radius:14px;padding:14px 14px 18px;box-shadow:0 8px 28px rgba(0,0,0,.35);display:flex;flex-direction:column;gap:12px}
    h1{font-size:18px;margin:0 0 4px}
    .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .stats{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
    .stat{background:#f4f7fb;border-radius:10px;padding:8px 10px;text-align:center}
    .controls{display:grid;grid-template-columns:1fr;gap:10px}
    button{appearance:none;border:0;border-radius:12px;padding:10px 12px;font-weight:700;cursor:pointer;transition:transform .05s ease, box-shadow .2s ease;box-shadow:0 2px 0 rgba(0,0,0,.2)}
    button:hover{transform:translateY(-1px)}
    .primary{background:var(--accent);color:#fff}
    .secondary{background:var(--accent-2);color:#fff}
    .danger{background:var(--danger);color:#fff}
    .small{font-size:12px;font-weight:600;padding:6px 8px;border-radius:8px}
    .tower-list{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .tower{background:#eef2ff;border:2px solid transparent;border-radius:12px;padding:8px;display:flex;flex-direction:column;gap:6px}
    .tower.selected{border-color:var(--accent-2)}
    .tower h3{margin:0;font-size:14px}
    .tower .meta{display:flex;justify-content:space-between;font-size:12px;color:#334155}
    .legend{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px}
    .chip{display:flex;align-items:center;gap:6px;background:#f8fafc;border-radius:999px;padding:6px 8px;font-size:12px;color:#334155}
    .bullet{width:12px;height:12px;border-radius:50%}
    .notice{background:#fff7ed;color:#7c2d12;border:1px solid #fed7aa;border-radius:10px;padding:10px 12px;font-size:13px}
    .muted{color:#6b7280}
    .link{color:#2563eb;text-decoration:underline;cursor:pointer}
    .footer{margin-top:auto;font-size:12px;color:#64748b}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:#111827;color:#e5e7eb;border-radius:6px;padding:2px 6px;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="960" height="600" aria-label="Goose TD game canvas"></canvas>
    <aside>
      <div class="row" style="justify-content:space-between">
        <h1>Goose TD ‚Äî Birthday Edition</h1>
        <button id="btnReset" class="small danger" title="Reset game">Reset</button>
      </div>
      <div class="stats">
        <div class="stat"><div class="muted">Wave</div><div><span id="uiWave">1</span> / 10</div></div>
        <div class="stat"><div class="muted">Money</div><div>üí∞ <span id="uiMoney">0</span></div></div>
        <div class="stat"><div class="muted">Lives</div><div>‚ù§Ô∏è <span id="uiLives">0</span></div></div>
      </div>

      <div class="controls">
        <button id="btnStart" class="primary">‚ñ∂Ô∏è Start Wave</button>
        <div class="notice">Place towers on the grass (not on the dirt path or river). Click a family member, then click the map to place. You can cancel with <span class="kbd">Esc</span>.</div>
        <div class="tower-list" id="towerList"></div>
        <div class="legend">
          <div class="chip"><span class="bullet" style="background:#f87171"></span> Mom (Dynamite)</div>
          <div class="chip"><span class="bullet" style="background:#60a5fa"></span> Dad (Bowling)</div>
          <div class="chip"><span class="bullet" style="background:#fbbf24"></span> Jake (Boulder)</div>
          <div class="chip"><span class="bullet" style="background:#34d399"></span> Alex (Sword)</div>
          <div class="chip"><span class="bullet" style="background:#a78bfa"></span> Wasabi (Claws)</div>
          <div class="chip"><span class="bullet" style="background:#f472b6"></span> Adam (Dumbbell)</div>
        </div>
      </div>

      <div class="footer">High score (waves cleared): <span id="uiHigh">0</span>. This game autosaves best score in your browser.</div>
    </aside>
  </div>

  <script>
  // Goose TD ‚Äî Birthday Edition (single-file, no dependencies)
  // Author: You + ChatGPT ü•≥  
  // Notes:
  // - Place towers on grass. 10 waves of geese, culminating in a Super Goose boss.
  // - High score saved in localStorage under key 'goose_td_high'.

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const UI = {
    wave: document.getElementById('uiWave'),
    money: document.getElementById('uiMoney'),
    lives: document.getElementById('uiLives'),
    high: document.getElementById('uiHigh'),
    start: document.getElementById('btnStart'),
    reset: document.getElementById('btnReset'),
    towerList: document.getElementById('towerList'),
  };

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Map layout
  const PATH_WIDTH = 30;          // visual width of dirt path
  const NO_BUILD_PAD = 40;        // extra buffer where towers cannot be placed (from path)

  const RIVER = {x: 430, y: 160, w: 100, h: 280};
  const BRIDGE = {x: 410, y: 210, w: 140, h: 80}; // a rectangle covering the river for visuals

  // Path waypoints (from left to right; crosses the bridge area)
  const WAYPOINTS = [
    {x:-40, y:120},
    {x:220, y:120},
    {x:320, y:170},
    {x:480, y:190}, // across the bridge
    {x:620, y:250},
    {x:780, y:250},
    {x:980, y:330}
  ];

  const clamp = (v, a, b)=> Math.max(a, Math.min(b, v));
  const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

  function distPointToSegment(p, a, b){
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const ab2 = abx*abx + aby*aby;
    const t = ab2 ? clamp((apx*abx + apy*aby) / ab2, 0, 1) : 0;
    const cx = a.x + t*abx, cy = a.y + t*aby;
    return Math.hypot(p.x - cx, p.y - cy);
  }

  function pointNearPath(p){
    // Inside path band + buffer?
    const threshold = (PATH_WIDTH/2) + NO_BUILD_PAD;
    for(let i=0;i<WAYPOINTS.length-1;i++){
      if(distPointToSegment(p, WAYPOINTS[i], WAYPOINTS[i+1]) <= threshold) return true;
    }
    return false;
  }

  function pointInRect(p, r){return p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h;}

  // Enemy (Goose) types
  const GooseTypes = {
    gosling:   {name:'Gosling',    hp:20,  speed: 60, reward:5,  radius:10, color:'#ffffff'},
    adult:     {name:'Adult Goose',hp:35,  speed: 65, reward:7,  radius:12, color:'#ddd'},
    fast:      {name:'Fast Goose', hp:30,  speed:100, reward:8,  radius:10, color:'#e5e7eb'},
    tank:      {name:'Tank Goose', hp:60,  speed: 55, reward:10, radius:13, color:'#cbd5e1'},
    armored:   {name:'Armored',    hp:100, speed: 55, reward:12, radius:14, color:'#94a3b8'},
    golden:    {name:'Golden',     hp:80,  speed: 60, reward:18, radius:12, color:'#facc15'},
    ninja:     {name:'Ninja',      hp:90,  speed:110, reward:14, radius:11, color:'#9ca3af'},
    giant:     {name:'Giant',      hp:200, speed: 50, reward:25, radius:16, color:'#9ca3af'},
    boss:      {name:'Super Goose',hp:600, speed: 60, reward:100,radius:20, color:'#f87171'},
  };

  // Towers (family)
  const TowerDefs = {
    mom:   {name:'Mom',   desc:'Throws dynamite (splash)',  color:'#f87171', cost:120, dmg:18,  range:120, fireRate:0.8, type:'splash', splash:42, projSpeed:220},
    dad:   {name:'Dad',   desc:'Bowls a bowling ball (pierce)', color:'#60a5fa', cost:100, dmg:10,  range:140, fireRate:0.6, type:'pierce', pierce:3, projSpeed:260},
    jake:  {name:'Jake',  desc:'Tosses a boulder',         color:'#fbbf24', cost:140, dmg:28,  range:150, fireRate:1.0, type:'projectile', projSpeed:210},
    alex:  {name:'Alex',  desc:'Sword slashes (melee)',     color:'#34d399', cost:80,  dmg:6,   range:60,  fireRate:0.2, type:'melee'},
    wasabi:{name:'Wasabi',desc:'Cat claws (rapid)',         color:'#a78bfa', cost:60,  dmg:2,   range:55,  fireRate:0.1, type:'melee'},
    adam:  {name:'Adam',  desc:'Throws a dumbbell',         color:'#f472b6', cost:90,  dmg:8,   range:130, fireRate:0.35,type:'projectile', projSpeed:250},
  };

  // Damage multipliers: towerId -> gooseType -> multiplier
  const DMG_MULTI = {
    mom:   { gosling:1.0, adult:1.1, fast:1.0, tank:1.2, armored:1.2, golden:1.0, ninja:0.9, giant:1.2, boss:1.1 },
    dad:   { gosling:1.0, adult:1.1, fast:1.4, tank:1.0, armored:0.9, golden:1.0, ninja:1.2, giant:1.0, boss:1.0 },
    jake:  { gosling:0.9, adult:1.0, fast:0.8, tank:1.3, armored:1.5, golden:1.0, ninja:0.85, giant:1.5, boss:1.4 },
    alex:  { gosling:1.1, adult:1.0, fast:1.1, tank:0.9, armored:0.8, golden:1.0, ninja:1.3, giant:0.95, boss:0.9 },
    wasabi:{ gosling:1.6, adult:1.1, fast:1.6, tank:0.8, armored:0.7, golden:1.0, ninja:1.5, giant:0.8, boss:0.75 },
    adam:  { gosling:1.1, adult:1.2, fast:1.0, tank:1.0, armored:1.0, golden:1.2, ninja:1.0, giant:1.0, boss:1.0 },
  };

  // Waves config (10 waves)
  const WAVES = [
    {name:'Goslings',    list:[['gosling',12]]},
    {name:'Adults',      list:[['adult',10]]},
    {name:'Swift Honkers',list:[['fast',18]]},
    {name:'Tanks',       list:[['tank',12]]},
    {name:'Mixed',       list:[['fast',10],['adult',10]]},
    {name:'Armored',     list:[['armored',12]]},
    {name:'Golden Run',  list:[['golden',14]]},
    {name:'Ninjas',      list:[['ninja',20]]},
    {name:'Giants',      list:[['giant',10]]},
    {name:'SUPER GOOSE', list:[['boss',1],['fast',12],['armored',6]]},
  ];

  // Game state
  const state = {
    money: 250,
    lives: 20,
    waveIndex: 0, // 0..9
    inWave: false,
    enemies: [],
    towers: [],
    projectiles: [],
    placing: null, // {id, def}
    lastTime: 0,
    spawnTimer: 0,
    spawnQueue: [],
    gameOver: false,
    victory: false,
  };

  // UI tower cards
  function buildTowerList(){
    UI.towerList.innerHTML = '';
    Object.entries(TowerDefs).forEach(([id,def])=>{
      const el = document.createElement('button');
      el.className = 'tower';
      el.innerHTML = `<h3>${def.name}</h3>
        <div class="meta"><span>$${def.cost}</span><span>${def.desc}</span></div>`;
      el.addEventListener('click', ()=>{
        state.placing = {id, def};
        refreshTowerSelection();
      });
      el.dataset.id = id;
      UI.towerList.appendChild(el);
    });
    refreshTowerSelection();
  }
  function refreshTowerSelection(){
    [...UI.towerList.children].forEach(btn=>{
      btn.classList.toggle('selected', state.placing && btn.dataset.id === state.placing.id);
    });
  }

  function resetGame(){
    state.money = 250;
    state.lives = 20;
    state.waveIndex = 0;
    state.inWave = false;
    state.enemies.length = 0;
    state.towers.length = 0;
    state.projectiles.length = 0;
    state.placing = null;
    state.spawnTimer = 0;
    state.spawnQueue = [];
    state.gameOver = false;
    state.victory = false;
    UI.wave.textContent = (state.waveIndex+1);
    UI.money.textContent = state.money;
    UI.lives.textContent = state.lives;
  }

  // Enemy class
  class Enemy{
    constructor(kind){
      this.kind = kind; // key in GooseTypes
      const t = GooseTypes[kind];
      this.maxHp = t.hp;
      this.hp = t.hp;
      this.speed = t.speed; // px/sec
      this.reward = t.reward;
      this.radius = t.radius;
      this.color = t.color;
      this.pos = {x:WAYPOINTS[0].x, y:WAYPOINTS[0].y};
      this.wp = 1; // next waypoint index
      this.dead = false;
    }
    update(dt){
      if(this.dead) return;
      const target = WAYPOINTS[this.wp];
      const dx = target.x - this.pos.x;
      const dy = target.y - this.pos.y;
      const d = Math.hypot(dx, dy);
      if(d < 1){
        this.wp++;
        if(this.wp >= WAYPOINTS.length){
          this.dead = true; // reached end
          state.lives -= 1;
          UI.lives.textContent = state.lives;
          if(state.lives <= 0) endGame(false);
        }
        return;
      }
      const vx = (dx / d) * this.speed * dt;
      const vy = (dy / d) * this.speed * dt;
      this.pos.x += vx; this.pos.y += vy;
    }
    draw(){
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(0,0, this.radius+6, this.radius, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#111827';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('ü¶¢', 0, 0);
      // hp bar
      const w = 30, h = 4;
      ctx.fillStyle = '#00000066';
      ctx.fillRect(-w/2, -this.radius-10, w, h);
      ctx.fillStyle = '#10b981';
      ctx.fillRect(-w/2, -this.radius-10, w * (this.hp/this.maxHp), h);
      ctx.restore();
    }
  }

  class Projectile{
    constructor(opts){
      Object.assign(this, opts); // pos, vel, dmg, color, radius, pierce, splash, ownerId
      this.dead = false;
      this.hitCount = 0;
    }
    update(dt){
      if(this.dead) return;
      this.pos.x += this.vel.x * dt;
      this.pos.y += this.vel.y * dt;
      // offscreen cleanup
      if(this.pos.x < -20 || this.pos.x > WIDTH+20 || this.pos.y < -20 || this.pos.y > HEIGHT+20) this.dead = true;
      // collisions
      for(const e of state.enemies){
        if(e.dead) continue;
        const d = dist(this.pos, e.pos);
        if(d <= (this.radius + e.radius)){
          this.applyDamage(e);
          if(this.splash){
            for(const e2 of state.enemies){
              if(e2 === e || e2.dead) continue;
              if(dist(e2.pos, e.pos) <= this.splash) this.applyDamage(e2, 0.7);
            }
          }
          this.hitCount++;
          if(!this.pierce || this.hitCount >= this.pierce) { this.dead = true; }
          break;
        }
      }
    }
    applyDamage(enemy, mult=1){
      enemy.hp -= this.dmg * mult * getDamageMult(this.ownerId, enemy.kind);
      if(enemy.hp <= 0 && !enemy.dead){
        enemy.dead = true;
        state.money += enemy.reward;
        UI.money.textContent = state.money;
      }
    }
    draw(){
      ctx.save();
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  class Tower{
    constructor(id, x, y){
      this.id = id; // key in TowerDefs
      this.def = TowerDefs[id];
      this.x = x; this.y = y;
      this.cool = 0; // fire cooldown seconds
    }
    update(dt){
      this.cool -= dt; if(this.cool < 0) this.cool = 0;
      // acquire nearest enemy in range
      let target=null, td=Infinity;
      for(const e of state.enemies){
        if(e.dead) continue;
        const d = Math.hypot(e.pos.x - this.x, e.pos.y - this.y);
        if(d <= this.def.range && d < td){ target = e; td = d; }
      }
      if(!target) return;

      if(this.def.type === 'melee'){
        if(this.cool <= 0){
          // damage directly to target (and soft splash to nearby geese)
          target.hp -= this.def.dmg * getDamageMult(this.id, target.kind);
          if(target.hp <= 0 && !target.dead){ target.dead = true; state.money += target.reward; UI.money.textContent = state.money; }
          // tiny cleave
          for(const e2 of state.enemies){
            if(e2===target || e2.dead) continue;
            if(Math.hypot(e2.pos.x - this.x, e2.pos.y - this.y) <= this.def.range*0.6){
              e2.hp -= (this.def.dmg*0.5) * getDamageMult(this.id, e2.kind);
              if(e2.hp <= 0 && !e2.dead){ e2.dead = true; state.money += e2.reward; UI.money.textContent = state.money; }
            }
          }
          this.cool = this.def.fireRate;
        }
        return;
      }

      if(this.cool > 0) return;
      // fire a projectile towards target
      const dx = target.pos.x - this.x;
      const dy = target.pos.y - this.y;
      const d = Math.hypot(dx, dy)||1;
      const vx = (dx/d) * this.def.projSpeed;
      const vy = (dy/d) * this.def.projSpeed;
      const proj = new Projectile({
        pos:{x:this.x, y:this.y},
        vel:{x:vx, y:vy},
        dmg:this.def.dmg,
        color:this.def.color,
        radius: this.id==='dad'? 7 : this.id==='jake'? 8 : this.id==='mom'? 7 : 5,
        pierce: this.def.pierce||0,
        splash: this.def.splash||0,
        ownerId: this.id,
      });
      state.projectiles.push(proj);
      this.cool = this.def.fireRate;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x, this.y);
      // base
      ctx.fillStyle = this.def.color;
      ctx.beginPath();
      ctx.arc(0,0, 14, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = '#1f2937'; ctx.stroke();
      // icon/emoji hint
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle = '#111827';
      const icon = this.id==='mom'?'üí£': this.id==='dad'?'üé≥': this.id==='jake'?'ü™®': this.id==='alex'?'üó°Ô∏è': this.id==='wasabi'?'üêæ':'üèãÔ∏è';
      ctx.fillText(icon, 0,0);
      ctx.restore();
    }
  }

  function getDamageMult(towerId, gooseKind){
    const m = DMG_MULTI[towerId] && DMG_MULTI[towerId][gooseKind];
    return m || 1.0;
  }

  // Spawning logic
  function startWave(){
    if(state.inWave || state.gameOver) return;
    state.inWave = true;
    const w = WAVES[state.waveIndex];
    state.spawnQueue = [];
    for(const [kind,count] of w.list){
      for(let i=0;i<count;i++) state.spawnQueue.push(kind);
    }
    state.spawnTimer = 0; // spawn immediately
  }

  function checkWaveClear(){
    if(!state.inWave) return;
    const anyAlive = state.enemies.some(e=>!e.dead) || state.spawnQueue.length>0;
    if(!anyAlive){
      // wave finished
      state.inWave = false;
      // Next wave or victory
      if(state.waveIndex < WAVES.length-1){
        state.waveIndex++;
        UI.wave.textContent = (state.waveIndex+1);
        // bonus money
        state.money += 50 + state.waveIndex*10;
        UI.money.textContent = state.money;
        // update high score (waves cleared)
        const cleared = state.waveIndex; // just finished previous wave
        updateHighScore(cleared);
      } else {
        endGame(true);
      }
    }
  }

  function endGame(victory){
    state.gameOver = true;
    state.victory = victory;
    const cleared = victory? WAVES.length : state.waveIndex; // if died during wave N+1, count N
    updateHighScore(cleared);
  }

  function updateHighScore(wavesCleared){
    const key = 'goose_td_high';
    const prev = Number(localStorage.getItem(key)||'0');
    if(wavesCleared>prev){ localStorage.setItem(key, String(wavesCleared)); }
    UI.high.textContent = localStorage.getItem(key)||'0';
  }

  // Mouse input
  const mouse = {x:0,y:0, onCanvas:false};
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width/rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height/rect.height);
  });
  canvas.addEventListener('mouseenter',()=>mouse.onCanvas=true);
  canvas.addEventListener('mouseleave',()=>mouse.onCanvas=false);
  canvas.addEventListener('click', ()=>{
    if(!state.placing) return;
    const {id, def} = state.placing;
    if(state.money < def.cost) return alert('Not enough money.');
    const p = {x:mouse.x, y:mouse.y};
    if(inNoBuild(p)){
      flashMsg('Cannot build on the path or river.');
      return;
    }
    // too close to other towers?
    for(const t of state.towers){ if(Math.hypot(t.x-p.x, t.y-p.y) < 34) { flashMsg('Too close to another tower.'); return; } }
    state.towers.push(new Tower(id, p.x, p.y));
    state.money -= def.cost; UI.money.textContent = state.money;
  });
  window.addEventListener('keydown', e=>{ if(e.key==='Escape'){ state.placing=null; refreshTowerSelection(); } });

  function inNoBuild(p){
    if(pointNearPath(p)) return true;
    if(pointInRect(p, RIVER) && !pointInRect(p, BRIDGE)) return true; // allow the bridge visual rectangle but better to disallow building on bridge too
    if(pointInRect(p, BRIDGE)) return true; // disallow bridge to keep it tidy
    return false;
  }

  // Simple toast-like message
  let toastTimer=0, toastText='';
  function flashMsg(text){ toastText=text; toastTimer=1.8; }

  // Draw map
  function drawMap(){
    // grass
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--grass');
    ctx.fillRect(0,0, WIDTH, HEIGHT);

    // river
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--river');
    roundRect(RIVER.x, RIVER.y, RIVER.w, RIVER.h, 18); ctx.fill();

    // bridge (visual)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bridge');
    roundRect(BRIDGE.x, BRIDGE.y, BRIDGE.w, BRIDGE.h, 10); ctx.fill();

    // dirt path
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--path');
    ctx.lineWidth = PATH_WIDTH;
    ctx.beginPath();
    ctx.moveTo(WAYPOINTS[0].x, WAYPOINTS[0].y);
    for(let i=1;i<WAYPOINTS.length;i++) ctx.lineTo(WAYPOINTS[i].x, WAYPOINTS[i].y);
    ctx.stroke();

    // Bridge planks lines over the dirt where it crosses river
    ctx.strokeStyle = '#5b3a1d';
    ctx.lineWidth = 6;
    for(let x=BRIDGE.x+10; x<BRIDGE.x+BRIDGE.w-10; x+=18){
      ctx.beginPath(); ctx.moveTo(x, BRIDGE.y+10); ctx.lineTo(x, BRIDGE.y+BRIDGE.h-10); ctx.stroke();
    }
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawUIOverlays(dt){
    // placement radius
    if(state.placing && mouse.onCanvas){
      const {def} = state.placing;
      ctx.save();
      ctx.globalAlpha = 0.15; ctx.fillStyle = def.color; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, def.range, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1; ctx.strokeStyle = def.color; ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, def.range, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
      // invalid placement hint
      if(inNoBuild({x:mouse.x,y:mouse.y}) || state.towers.some(t=>Math.hypot(t.x-mouse.x, t.y-mouse.y)<34)){
        ctx.fillStyle = '#ef4444'; ctx.font = 'bold 14px system-ui'; ctx.textAlign='center'; ctx.fillText('üö´ No build', mouse.x, mouse.y- def.range - 10);
      }
      ctx.restore();
    }

    // wave banner and hints
    if(!state.inWave && !state.gameOver){
      ctx.save();
      ctx.fillStyle = '#00000055';
      ctx.fillRect(16, 16, 260, 60);
      ctx.fillStyle = '#fff';
      ctx.font = '700 16px system-ui';
      ctx.fillText(`Upcoming: ${WAVES[state.waveIndex].name}`, 26, 42);
      ctx.font = '12px system-ui';
      ctx.fillText('Tip: place Wasabi near tight corners for max claw hits!', 26, 62);
      ctx.restore();
    }

    // toast
    if(toastTimer>0){ toastTimer-=dt; ctx.save(); ctx.globalAlpha = Math.min(1, toastTimer/0.2); ctx.fillStyle='#111827cc'; ctx.fillRect(WIDTH/2-150, 20, 300, 36); ctx.fillStyle='#fff'; ctx.font='bold 14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(toastText, WIDTH/2, 38); ctx.restore(); }

    // game over / victory
    if(state.gameOver){
      ctx.save();
      ctx.fillStyle = '#000000aa'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.fillStyle = state.victory? '#10b981' : '#ef4444';
      ctx.font = 'bold 36px system-ui'; ctx.textAlign='center';
      ctx.fillText(state.victory? 'You defended the park! üéâ' : 'The geese got through‚Ä¶ üíî', WIDTH/2, HEIGHT/2 - 20);
      ctx.font = '16px system-ui'; ctx.fillStyle='#fff';
      ctx.fillText('Press Reset to play again.', WIDTH/2, HEIGHT/2 + 16);
      ctx.restore();
    }
  }

  function update(dt){
    if(state.inWave){
      state.spawnTimer -= dt;
      if(state.spawnTimer <= 0 && state.spawnQueue.length>0){
        const kind = state.spawnQueue.shift();
        state.enemies.push(new Enemy(kind));
        state.spawnTimer = 0.55; // spawn cadence
      }
    }

    for(const e of state.enemies) e.update(dt);
    state.enemies = state.enemies.filter(e=>!e.dead || e.hp>0); // keep those that either alive or reached end? note: reached end sets dead=true; filtered out

    for(const t of state.towers) t.update(dt);

    for(const p of state.projectiles) p.update(dt);
    state.projectiles = state.projectiles.filter(p=>!p.dead);

    if(state.inWave) checkWaveClear();
  }

  function draw(){
    drawMap();

    // range rings on hover over a tower
    let hoverIdx = -1;
    for(let i=0;i<state.towers.length;i++){
      const t = state.towers[i];
      if(Math.hypot(mouse.x - t.x, mouse.y - t.y) < 16) hoverIdx = i;
    }

    // enemies under towers ordering? draw path -> range -> towers -> projectiles -> enemies -> overlays
    // draw enemies behind projectiles for clarity
    for(const e of state.enemies) e.draw();

    for(const p of state.projectiles) p.draw();

    for(let i=0;i<state.towers.length;i++){
      const t = state.towers[i];
      if(i===hoverIdx){
        ctx.save(); ctx.globalAlpha = .1; ctx.fillStyle=t.def.color; ctx.beginPath(); ctx.arc(t.x,t.y,t.def.range,0,Math.PI*2); ctx.fill(); ctx.restore();
        ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle=t.def.color; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(t.x,t.y,t.def.range,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
      }
      t.draw();
    }

    // placing ghost
    if(state.placing && mouse.onCanvas){
      ctx.save();
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = state.placing.def.color;
      ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 12, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.033, (now - last)/1000); // clamp dt
    last = now;
    update(dt);
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    draw();
    drawUIOverlays(dt);
    requestAnimationFrame(frame);
  }

  // Hook up UI
  UI.start.addEventListener('click', startWave);
  UI.reset.addEventListener('click', ()=>{ resetGame(); });

  function init(){
    buildTowerList();
    resetGame();
    UI.high.textContent = localStorage.getItem('goose_td_high')||'0';
    requestAnimationFrame(frame);
  }
  init();

  </script>
</body>
</html>
